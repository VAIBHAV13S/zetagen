import express from 'express';
import { ethers } from 'ethers';
import Asset from '../models/Asset.js';
import {
  crossChainMintAsset,
  mintAsset,
  batchMintAssets,
  isAssetMinted,
  getAssetMetadata,
  getUserAssets,
  getContractInfo
} from '../services/zetaForgeUniversalService.js';
import { asyncHandler } from '../middleware/errorHandler.js';

const router = express.Router();

// GET /api/mint/info - Get contract information
router.get('/mint/info', asyncHandler(async (req, res) => {
  const contractInfo = await getContractInfo();
  
  res.json({
    success: true,
    contractInfo
  });
}));

// POST /api/mint - Mint an asset as NFT using Universal Contract with enhanced features
router.post('/mint', asyncHandler(async (req, res) => {
  const { assetId, walletAddress, sourceChain = 7001, gasOptimization = true } = req.body;

  // Enhanced validation
  if (!assetId || !walletAddress) {
    return res.status(400).json({
      success: false,
      error: 'Asset ID and wallet address are required'
    });
  }

  if (!ethers.isAddress(walletAddress)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid wallet address format'
    });
  }

  // Find the asset in database
  const asset = await Asset.findOne({ assetId });
  
  if (!asset) {
    return res.status(404).json({
      success: false,
      error: 'Asset not found'
    });
  }

  // Check if asset is already minted
  if (asset.isMinted) {
    return res.status(400).json({
      success: false,
      error: 'Asset is already minted',
      txHash: asset.mintTxHash,
      tokenId: asset.metadata.tokenId
    });
  }

  // Double-check on blockchain with enhanced service
  const alreadyMintedOnChain = await isAssetMinted(assetId);
  if (alreadyMintedOnChain) {
    await asset.markAsMinted('unknown', 'unknown');
    
    return res.status(400).json({
      success: false,
      error: 'Asset is already minted on blockchain',
      recommendation: 'Asset status synchronized with blockchain'
    });
  }

  // Verify ownership
  if (asset.ownerAddress.toLowerCase() !== walletAddress.toLowerCase()) {
    return res.status(403).json({
      success: false,
      error: 'Only the asset owner can mint this NFT'
    });
  }

  console.log(`🪙 Initiating enhanced Universal cross-chain mint for asset ${assetId}`);
  
  // Create enhanced metadata URI using our backend
  const baseURL = process.env.NODE_ENV === 'production' 
    ? 'https://zetaforge-backend.onrender.com' 
    : 'http://localhost:5000';
  const metadataURI = `${baseURL}/api/metadata/${assetId}`;
  
  console.log(`🔗 Metadata URI: ${metadataURI}`);
  
  // Test metadata URI accessibility before minting
  try {
    const testResponse = await fetch(metadataURI);
    if (!testResponse.ok) {
      throw new Error(`Metadata URI not accessible: ${testResponse.status} ${testResponse.statusText}`);
    }
    const metadata = await testResponse.json();
    console.log(`✅ Metadata URI is accessible and returns valid data:`, {
      name: metadata.name,
      imageExists: !!metadata.image,
      attributesCount: metadata.attributes?.length || 0
    });
  } catch (error) {
    console.error(`❌ Metadata URI test failed:`, error);
    return res.status(400).json({
      success: false,
      error: 'Invalid metadata URI',
      details: error.message,
      metadataURI
    });
  }
  
  // Prepare enhanced traits from metadata
  const traits = asset.metadata.traits ? JSON.stringify([
    ...asset.metadata.traits,
    { type: 'Generated By', value: 'ZetaForge AI' },
    { type: 'Generation Model', value: asset.generationParameters?.model || 'gemini-2.0-flash-exp' },
    { type: 'Style', value: asset.generationParameters?.style || 'digital-art' },
    { type: 'Quality', value: asset.generationParameters?.quality || 'high' }
  ]) : '';

  const startTime = Date.now();
  
  console.log(`📋 Cross-chain mint parameters:`, {
    walletAddress,
    sourceChain,
    assetId,
    prompt: asset.prompt.substring(0, 50) + '...',
    metadataURI,
    traitsCount: traits ? JSON.parse(traits).length : 0
  });
  
  // Execute enhanced cross-chain mint with retry mechanism
  console.log(`🔧 Debug - About to call crossChainMintAsset with parameters:`, {
    walletAddress,
    sourceChain,
    assetId,
    prompt: asset.prompt.substring(0, 50) + '...',
    metadataURI,
    traitsLength: traits ? traits.length : 0
  });
  
  const mintResult = await crossChainMintAsset(
    walletAddress,
    sourceChain,
    assetId,
    asset.prompt,
    metadataURI,
    traits
  );
  
  const executionTime = Date.now() - startTime;
  
  // Update asset in database
  await asset.markAsMinted(mintResult.hash, mintResult.tokenId);
  
  console.log(`✅ Successfully minted universal asset ${assetId} with tx: ${mintResult.hash}`);
  
  res.json({
    success: true,
    txHash: mintResult.hash,
    tokenId: mintResult.tokenId,
    sourceChain: mintResult.sourceChain,
    gasUsed: mintResult.gasUsed,
    mintFee: mintResult.mintFee,
    contractAddress: process.env.ZETAFORGE_UNIVERSAL_CONTRACT_ADDRESS,
    asset: {
      assetId: asset.assetId,
      owner: asset.ownerAddress,
      isMinted: true,
      mintTxHash: mintResult.hash,
      tokenId: mintResult.tokenId
    },
    performance: {
      executionTime: `${executionTime}ms`,
      gasOptimization: gasOptimization ? 'enabled' : 'disabled',
      retryAttempts: mintResult.retryAttempts || 0
    },
    metadata: {
      enhancedTraits: JSON.parse(traits).length,
      metadataURI,
      ipfsHash: mintResult.ipfsHash || null
    }
  });
}));

// POST /api/mint/direct - Direct mint an asset (bypasses relayer for immediate tokenId)
router.post('/mint/direct', asyncHandler(async (req, res) => {
  const { assetId, walletAddress, sourceChain = 7001, gasOptimization = true } = req.body;

  // Enhanced validation
  if (!assetId || !walletAddress) {
    return res.status(400).json({
      success: false,
      error: 'Asset ID and wallet address are required'
    });
  }

  if (!ethers.isAddress(walletAddress)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid wallet address format'
    });
  }

  // Find the asset in database
  const asset = await Asset.findOne({ assetId });
  
  if (!asset) {
    return res.status(404).json({
      success: false,
      error: 'Asset not found'
    });
  }

  // Check if asset is already minted - allow re-mint if tokenId is 0 (failed previous mint)
  if (asset.isMinted && asset.metadata.tokenId !== "0") {
    return res.status(400).json({
      success: false,
      error: 'Asset is already minted',
      txHash: asset.mintTxHash,
      tokenId: asset.metadata.tokenId
    });
  }

  // If asset is marked as minted but tokenId is 0, allow re-mint (previous mint failed)
  if (asset.isMinted && asset.metadata.tokenId === "0") {
    console.log(`🔄 Asset ${assetId} was previously marked as minted but tokenId is 0 - allowing re-mint`);
  }

  // Double-check on blockchain with enhanced service
  const alreadyMintedOnChain = await isAssetMinted(assetId);
  if (alreadyMintedOnChain) {
    await asset.markAsMinted('unknown', 'unknown');
    
    return res.status(400).json({
      success: false,
      error: 'Asset is already minted on blockchain',
      recommendation: 'Asset status synchronized with blockchain'
    });
  }

  // Verify ownership
  if (asset.ownerAddress.toLowerCase() !== walletAddress.toLowerCase()) {
    return res.status(403).json({
      success: false,
      error: 'Only the asset owner can mint this NFT'
    });
  }

  console.log(`🪙 Initiating direct mint for asset ${assetId}`);
  
  // Create enhanced metadata URI using our backend
  const baseURL = process.env.NODE_ENV === 'production' 
    ? 'https://zetaforge-backend.onrender.com' 
    : 'http://localhost:5000';
  const metadataURI = `${baseURL}/api/metadata/${assetId}`;
  
  console.log(`🔗 Metadata URI: ${metadataURI}`);
  
  // Test metadata URI accessibility before minting
  try {
    const testResponse = await fetch(metadataURI);
    if (!testResponse.ok) {
      throw new Error(`Metadata URI not accessible: ${testResponse.status} ${testResponse.statusText}`);
    }
    const metadata = await testResponse.json();
    console.log(`✅ Metadata URI is accessible and returns valid data:`, {
      name: metadata.name,
      imageExists: !!metadata.image,
      attributesCount: metadata.attributes?.length || 0
    });
  } catch (error) {
    console.error(`❌ Metadata URI test failed:`, error);
    return res.status(400).json({
      success: false,
      error: 'Invalid metadata URI',
      details: error.message,
      metadataURI
    });
  }
  
  // Prepare enhanced traits from metadata
  const traits = asset.metadata.traits ? JSON.stringify([
    ...asset.metadata.traits,
    { type: 'Generated By', value: 'ZetaForge AI' },
    { type: 'Generation Model', value: asset.generationParameters?.model || 'gemini-2.0-flash-exp' },
    { type: 'Style', value: asset.generationParameters?.style || 'digital-art' },
    { type: 'Quality', value: asset.generationParameters?.quality || 'high' },
    { type: 'Mint Type', value: 'Direct Mint' }
  ]) : '';

  const startTime = Date.now();
  
  console.log(`📋 Direct mint parameters:`, {
    walletAddress,
    sourceChain,
    assetId,
    prompt: asset.prompt.substring(0, 50) + '...',
    metadataURI,
    traitsCount: traits ? JSON.parse(traits).length : 0
  });
  
  // Execute direct mint
  console.log(`🔧 Debug - About to call mintAsset with parameters:`, {
    walletAddress,
    sourceChain,
    assetId,
    prompt: asset.prompt.substring(0, 50) + '...',
    metadataURI,
    traitsLength: traits ? traits.length : 0
  });
  
  const mintResult = await mintAsset(
    walletAddress,
    sourceChain,
    assetId,
    asset.prompt,
    metadataURI,
    traits
  );
  
  const executionTime = Date.now() - startTime;
  
  // Update asset in database
  await asset.markAsMinted(mintResult.hash, mintResult.tokenId);
  
  console.log(`✅ Successfully direct minted asset ${assetId} with tx: ${mintResult.hash}`);
  
  res.json({
    success: true,
    txHash: mintResult.hash,
    tokenId: mintResult.tokenId,
    sourceChain: mintResult.sourceChain,
    gasUsed: mintResult.gasUsed,
    mintFee: mintResult.mintFee,
    contractAddress: process.env.ZETAFORGE_UNIVERSAL_CONTRACT_ADDRESS,
    asset: {
      assetId: asset.assetId,
      owner: asset.ownerAddress,
      isMinted: true,
      mintTxHash: mintResult.hash,
      tokenId: mintResult.tokenId
    },
    performance: {
      executionTime: `${executionTime}ms`,
      gasOptimization: gasOptimization ? 'enabled' : 'disabled',
      mintType: 'direct'
    },
    metadata: {
      enhancedTraits: JSON.parse(traits).length,
      metadataURI,
      ipfsHash: mintResult.ipfsHash || null
    }
  });
}));

// GET /api/mint/status/:assetId - Enhanced minting status with blockchain verification
router.get('/mint/status/:assetId', asyncHandler(async (req, res) => {
  const { assetId } = req.params;

  // First check database
  const asset = await Asset.findOne({ assetId }).lean();
  
  if (!asset) {
    return res.status(404).json({
      success: false,
      error: 'Asset not found'
    });
  }

  // Check blockchain status with enhanced service
  let blockchainInfo = null;
  try {
    blockchainInfo = await getAssetMetadata(assetId);
  } catch (error) {
    // Asset not minted on blockchain
    blockchainInfo = { isMinted: false, error: error.message };
  }

  // Check if database and blockchain are synced
  const synced = asset.isMinted === (blockchainInfo?.isMinted || false);

  res.json({
    success: true,
    assetId: asset.assetId,
    database: {
      isMinted: asset.isMinted,
      mintTxHash: asset.mintTxHash,
      tokenId: asset.metadata.tokenId,
      owner: asset.ownerAddress,
      createdAt: asset.createdAt,
      generationParameters: asset.generationParameters
    },
    blockchain: blockchainInfo,
    status: {
      synced,
      recommendation: !synced ? 'Database and blockchain states differ - consider re-syncing' : 'All systems synchronized',
      mintable: !asset.isMinted && !blockchainInfo?.isMinted,
      lastChecked: new Date().toISOString()
    }
  });
}));

// POST /api/mint/batch - Enhanced batch mint with intelligent processing
router.post('/mint/batch', asyncHandler(async (req, res) => {
  const { assetIds, walletAddress, sourceChain = 7001, batchSize = 3 } = req.body;

  if (!assetIds || !Array.isArray(assetIds) || assetIds.length === 0) {
    return res.status(400).json({
      success: false,
      error: 'Asset IDs array is required'
    });
  }

  if (assetIds.length > 10) {
    return res.status(400).json({
      success: false,
      error: 'Maximum 10 assets allowed per batch'
    });
  }

  if (!ethers.isAddress(walletAddress)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid wallet address format'
    });
  }

  const startTime = Date.now();
  const results = [];
  const errors = [];
  
  // Prepare batch mint requests
  const mintRequests = [];
  
  for (const assetId of assetIds) {
    try {
      const asset = await Asset.findOne({ assetId });
      
      if (!asset) {
        errors.push({ assetId, error: 'Asset not found' });
        continue;
      }

      if (asset.isMinted) {
        errors.push({ assetId, error: 'Already minted' });
        continue;
      }

      // Check blockchain status
      const alreadyMintedOnChain = await isAssetMinted(assetId);
      if (alreadyMintedOnChain) {
        await asset.markAsMinted('unknown', 'unknown');
        errors.push({ assetId, error: 'Already minted on blockchain' });
        continue;
      }

      // Verify ownership
      if (asset.ownerAddress.toLowerCase() !== walletAddress.toLowerCase()) {
        errors.push({ assetId, error: 'Not owner' });
        continue;
      }

      // Prepare enhanced metadata
      const baseURL = process.env.NODE_ENV === 'production' 
        ? 'https://zetaforge-backend.onrender.com' 
        : 'http://localhost:5000';
      const metadataURI = `${baseURL}/api/metadata/${assetId}`;
      const traits = JSON.stringify([
        ...(asset.metadata.traits || []),
        { type: 'Batch Minted', value: 'true' },
        { type: 'Generated By', value: 'ZetaForge AI' }
      ]);

      mintRequests.push({
        walletAddress,
        sourceChain,
        assetId,
        prompt: asset.prompt,
        metadataURI,
        traits,
        asset // Keep reference for database update
      });

    } catch (error) {
      errors.push({ assetId, error: error.message });
    }
  }

  if (mintRequests.length === 0) {
    return res.status(400).json({
      success: false,
      error: 'No valid assets to mint',
      errors
    });
  }

  // Execute batch minting with enhanced service
  try {
    const batchResult = await batchMintAssets(mintRequests, Math.min(batchSize, 5));
    
    // Update database for successful mints
    for (const result of batchResult.successful) {
      const request = mintRequests.find(req => req.assetId === result.assetId);
      if (request?.asset) {
        await request.asset.markAsMinted(result.hash, result.tokenId);
      }
      results.push(result);
    }

    // Add batch errors to individual errors
    errors.push(...batchResult.failed);

    const executionTime = Date.now() - startTime;

    res.json({
      success: true,
      results,
      errors,
      summary: {
        totalRequested: assetIds.length,
        validAssets: mintRequests.length,
        successful: results.length,
        failed: errors.length,
        executionTime: `${executionTime}ms`,
        averageTimePerMint: results.length > 0 ? `${Math.round(executionTime / results.length)}ms` : 'N/A',
        batchSize: Math.min(batchSize, 5),
        gasOptimization: 'enabled'
      },
      batchMetrics: batchResult.metrics || {}
    });

  } catch (batchError) {
    console.error('❌ Batch mint error:', batchError);
    res.status(500).json({
      success: false,
      error: 'Batch minting failed',
      details: batchError.message,
      partialResults: results,
      errors
    });
  }
}));

// GET /api/mint/nfts/:walletAddress - Enhanced NFT retrieval with metadata
router.get('/mint/nfts/:walletAddress', asyncHandler(async (req, res) => {
  const { walletAddress } = req.params;
  const { includeMetadata = 'true', sortBy = 'newest' } = req.query;

  if (!ethers.isAddress(walletAddress)) {
    return res.status(400).json({
      success: false,
      error: 'Invalid wallet address format'
    });
  }

  // Get NFTs from enhanced blockchain service
  const nfts = await getUserAssets(walletAddress);

  // Enhance with database information
  const enhancedNFTs = await Promise.all(
    nfts.map(async (nft) => {
      try {
        const asset = await Asset.findOne({ assetId: nft.assetId }).lean();
        const enhanced = {
          ...nft,
          databaseInfo: asset ? {
            createdAt: asset.createdAt,
            updatedAt: asset.updatedAt,
            ownerAddress: asset.ownerAddress,
            prompt: asset.prompt,
            generationParameters: asset.generationParameters
          } : null
        };

        // Add metadata if requested
        if (includeMetadata === 'true') {
          try {
            const metadata = await getAssetMetadata(nft.assetId);
            enhanced.blockchainMetadata = metadata;
          } catch (error) {
            enhanced.metadataError = error.message;
          }
        }

        return enhanced;
      } catch (error) {
        console.warn(`Could not enhance NFT ${nft.assetId}:`, error.message);
        return nft;
      }
    })
  );

  // Sort NFTs
  const sortedNFTs = enhancedNFTs.sort((a, b) => {
    switch (sortBy) {
      case 'newest':
        return new Date(b.databaseInfo?.createdAt || 0) - new Date(a.databaseInfo?.createdAt || 0);
      case 'oldest':
        return new Date(a.databaseInfo?.createdAt || 0) - new Date(b.databaseInfo?.createdAt || 0);
      case 'tokenId':
        return parseInt(a.tokenId || 0) - parseInt(b.tokenId || 0);
      default:
        return 0;
    }
  });

  res.json({
    success: true,
    walletAddress,
    nfts: sortedNFTs,
    summary: {
      totalCount: enhancedNFTs.length,
      withMetadata: enhancedNFTs.filter(nft => nft.blockchainMetadata).length,
      withDatabaseInfo: enhancedNFTs.filter(nft => nft.databaseInfo).length,
      sortedBy: sortBy
    },
    timestamp: new Date().toISOString()
  });
}));

export default router;
